{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport { featureCollection, isNumber, isObject, lineString, point, polygon, validateBBox } from \"@turf/helpers\";\nfunction randomPosition(bbox) {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n__name(randomPosition, \"randomPosition\");\nfunction randomPositionUnchecked(bbox) {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n__name(randomPositionUnchecked, \"randomPositionUnchecked\");\nfunction checkBBox(bbox) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n__name(checkBBox, \"checkBBox\");\nfunction randomPoint(count, options = {}) {\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n__name(randomPoint, \"randomPoint\");\nfunction randomPolygon(count, options = {}) {\n  checkBBox(options.bbox);\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === void 0) {\n    options.num_vertices = 10;\n  }\n  if (!isNumber(options.max_radial_length) || options.max_radial_length === void 0) {\n    options.max_radial_length = 10;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n    circleOffsets.forEach((cur, index, arr) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n    circleOffsets.forEach(cur => {\n      cur = cur * 2 * Math.PI / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([radialScaler * (options.max_radial_length || 10) * Math.sin(cur), radialScaler * (options.max_radial_length || 10) * Math.cos(cur)]);\n    });\n    vertices[vertices.length - 1] = vertices[0];\n    vertices = vertices.map(vertexToCoordinate(randomPositionUnchecked(options.bbox)));\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n__name(randomPolygon, \"randomPolygon\");\nfunction randomLineString(count, options = {}) {\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === void 0 || count === null) {\n    count = 1;\n  }\n  if (!isNumber(num_vertices) || num_vertices === void 0 || num_vertices < 2) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === void 0) {\n    max_length = 1e-4;\n  }\n  if (!isNumber(max_rotation) || max_rotation === void 0) {\n    max_rotation = Math.PI / 8;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle = j === 0 ? Math.random() * 2 * Math.PI : Math.tan((vertices[j][1] - vertices[j - 1][1]) / (vertices[j][0] - vertices[j - 1][0]));\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([vertices[j][0] + distance * Math.cos(angle), vertices[j][1] + distance * Math.sin(angle)]);\n    }\n    features.push(lineString(vertices));\n  }\n  return featureCollection(features);\n}\n__name(randomLineString, \"randomLineString\");\nfunction vertexToCoordinate(hub) {\n  return cur => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n__name(vertexToCoordinate, \"vertexToCoordinate\");\nfunction rnd() {\n  return Math.random() - 0.5;\n}\n__name(rnd, \"rnd\");\nfunction lon() {\n  return rnd() * 360;\n}\n__name(lon, \"lon\");\nfunction lat() {\n  return rnd() * 180;\n}\n__name(lat, \"lat\");\nfunction coordInBBox(bbox) {\n  return [Math.random() * (bbox[2] - bbox[0]) + bbox[0], Math.random() * (bbox[3] - bbox[1]) + bbox[1]];\n}\n__name(coordInBBox, \"coordInBBox\");\nexport { randomLineString, randomPoint, randomPolygon, randomPosition };","map":{"version":3,"names":["featureCollection","isNumber","isObject","lineString","point","polygon","validateBBox","randomPosition","bbox","checkBBox","randomPositionUnchecked","__name","Array","isArray","coordInBBox","lon","lat","randomPoint","count","options","features","i","push","randomPolygon","num_vertices","max_radial_length","vertices","circleOffsets","map","Math","random","forEach","cur","index","arr","PI","length","radialScaler","sin","cos","vertexToCoordinate","randomLineString","Error","max_length","max_rotation","startingPoint","j","priorAngle","tan","angle","distance","hub","rnd"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/random/index.ts"],"sourcesContent":["import {\n  BBox,\n  FeatureCollection,\n  LineString,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  featureCollection,\n  isNumber,\n  isObject,\n  lineString,\n  point,\n  polygon,\n  validateBBox,\n} from \"@turf/helpers\";\n\n/**\n * Returns a random position within a {@link bounding box}.\n *\n * @name randomPosition\n * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Array<number>} Position [longitude, latitude]\n * @throws {Error} if bbox is invalid\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox?: BBox | { bbox: BBox }): Position {\n  checkBBox(bbox);\n  return randomPositionUnchecked(bbox);\n}\n\n// does not check bbox for validity, that is handled by the exported functions\nfunction randomPositionUnchecked(bbox?: BBox | { bbox: BBox }): Position {\n  if (Array.isArray(bbox)) {\n    return coordInBBox(bbox);\n  }\n  if (bbox && bbox.bbox) {\n    return coordInBBox(bbox.bbox);\n  }\n  return [lon(), lat()];\n}\n\nfunction checkBBox(bbox?: BBox | { bbox: BBox }) {\n  if (bbox == null) {\n    return;\n  } else if (Array.isArray(bbox)) {\n    validateBBox(bbox);\n  } else if (bbox.bbox != null) {\n    validateBBox(bbox.bbox);\n  }\n}\n\n/**\n * Returns a random {@link point}.\n *\n * @name randomPoint\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @throws {Error} if bbox is invalid\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(\n  count?: number,\n  options: {\n    bbox?: BBox;\n  } = {}\n): FeatureCollection<Point, any> {\n  checkBBox(options.bbox);\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    features.push(point(randomPositionUnchecked(options.bbox)));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link polygon}.\n *\n * @name randomPolygon\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @throws {Error} if bbox is invalid\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_radial_length?: number;\n  } = {}\n): FeatureCollection<Polygon, any> {\n  checkBBox(options.bbox);\n  // Default param\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n  if (!isNumber(options.num_vertices) || options.num_vertices === undefined) {\n    options.num_vertices = 10;\n  }\n  if (\n    !isNumber(options.max_radial_length) ||\n    options.max_radial_length === undefined\n  ) {\n    options.max_radial_length = 10;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    let vertices: any[] = [];\n    const circleOffsets = [...Array(options.num_vertices + 1)].map(Math.random);\n\n    // Sum Offsets\n    circleOffsets.forEach((cur: any, index: number, arr: any[]) => {\n      arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n    });\n\n    // scaleOffsets\n    circleOffsets.forEach((cur: any) => {\n      cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n      const radialScaler = Math.random();\n      vertices.push([\n        radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n        radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n      ]);\n    });\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n    // center the polygon around something\n    vertices = vertices.map(\n      vertexToCoordinate(randomPositionUnchecked(options.bbox))\n    );\n    features.push(polygon([vertices]));\n  }\n  return featureCollection(features);\n}\n\n/**\n * Returns a random {@link linestring}.\n *\n * @name randomLineString\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @throws {Error} if bbox is invalid\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(\n  count?: number,\n  options: {\n    bbox?: BBox;\n    num_vertices?: number;\n    max_length?: number;\n    max_rotation?: number;\n  } = {}\n): FeatureCollection<LineString, any> {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  const bbox = options.bbox;\n  checkBBox(bbox);\n  let num_vertices = options.num_vertices;\n  let max_length = options.max_length;\n  let max_rotation = options.max_rotation;\n  if (count === undefined || count === null) {\n    count = 1;\n  }\n\n  // Default parameters\n  if (\n    !isNumber(num_vertices) ||\n    num_vertices === undefined ||\n    num_vertices < 2\n  ) {\n    num_vertices = 10;\n  }\n  if (!isNumber(max_length) || max_length === undefined) {\n    max_length = 0.0001;\n  }\n  if (!isNumber(max_rotation) || max_rotation === undefined) {\n    max_rotation = Math.PI / 8;\n  }\n\n  const features = [];\n  for (let i = 0; i < count; i++) {\n    const startingPoint = randomPositionUnchecked(bbox);\n    const vertices = [startingPoint];\n    for (let j = 0; j < num_vertices - 1; j++) {\n      const priorAngle =\n        j === 0\n          ? Math.random() * 2 * Math.PI\n          : Math.tan(\n              (vertices[j][1] - vertices[j - 1][1]) /\n                (vertices[j][0] - vertices[j - 1][0])\n            );\n      const angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n      const distance = Math.random() * max_length;\n      vertices.push([\n        vertices[j][0] + distance * Math.cos(angle),\n        vertices[j][1] + distance * Math.sin(angle),\n      ]);\n    }\n    features.push(lineString(vertices));\n  }\n\n  return featureCollection(features);\n}\n\nfunction vertexToCoordinate(hub: number[]) {\n  return (cur: number[]) => {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\nfunction lon() {\n  return rnd() * 360;\n}\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction coordInBBox(bbox: BBox) {\n  return [\n    Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n    Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n  ];\n}\n\nexport { randomPosition, randomPoint, randomPolygon, randomLineString };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}