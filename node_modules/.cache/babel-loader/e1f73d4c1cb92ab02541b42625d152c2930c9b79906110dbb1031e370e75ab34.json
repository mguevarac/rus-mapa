{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.js\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject, isNumber } from \"@turf/helpers\";\nimport { centerMean } from \"@turf/center-mean\";\nimport { pointsWithinPolygon } from \"@turf/points-within-polygon\";\nimport { ellipse } from \"@turf/ellipse\";\nfunction standardDeviationalEllipse(points, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {};\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, {\n    weight: weightTerm\n  });\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = theta * 180 / Math.PI;\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum += Math.pow(deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta), 2) * weight;\n    sigmaYsum += Math.pow(deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta), 2) * weight;\n    weightsum += weight;\n  });\n  var sigmaX = Math.sqrt(2 * sigmaXsum / weightsum);\n  var sigmaY = Math.sqrt(2 * sigmaYsum / weightsum);\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps,\n    properties\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(points, featureCollection([theEllipse]));\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse: 100 * coordAll(pointsWithinEllipse).length / numberOfFeatures\n  };\n  theEllipse.properties.standardDeviationalEllipse = standardDeviationalEllipseProperties;\n  return theEllipse;\n}\n__name(standardDeviationalEllipse, \"standardDeviationalEllipse\");\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1]\n  };\n}\n__name(getDeviations, \"getDeviations\");\nvar turf_standard_deviational_ellipse_default = standardDeviationalEllipse;\nexport { turf_standard_deviational_ellipse_default as default, standardDeviationalEllipse };","map":{"version":3,"names":["coordAll","featureEach","getCoords","featureCollection","isObject","isNumber","centerMean","pointsWithinPolygon","ellipse","standardDeviationalEllipse","points","options","Error","steps","weightTerm","weight","properties","numberOfFeatures","length","meanCenter","xDeviationSquaredSum","yDeviationSquaredSum","xyDeviationSum","point","deviation","getDeviations","Math","pow","x","y","bigA","bigB","sqrt","bigC","theta","atan","thetaDeg","PI","sigmaXsum","sigmaYsum","weightsum","cos","sin","sigmaX","sigmaY","theEllipse","units","angle","pointsWithinEllipse","standardDeviationalEllipseProperties","meanCenterCoordinates","semiMajorAxis","semiMinorAxis","percentageWithinEllipse","__name","coordinates","center","turf_standard_deviational_ellipse_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/standard-deviational-ellipse/index.js"],"sourcesContent":["import { coordAll, featureEach } from \"@turf/meta\";\nimport { getCoords } from \"@turf/invariant\";\nimport { featureCollection, isObject, isNumber } from \"@turf/helpers\";\nimport { centerMean } from \"@turf/center-mean\";\nimport { pointsWithinPolygon } from \"@turf/points-within-polygon\";\nimport { ellipse } from \"@turf/ellipse\";\n\n/**\n * Takes a {@link FeatureCollection} and returns a standard deviational ellipse,\n * also known as a “directional distribution.” The standard deviational ellipse\n * aims to show the direction and the distribution of a dataset by drawing\n * an ellipse that contains about one standard deviation’s worth (~ 70%) of the\n * data.\n *\n * This module mirrors the functionality of [Directional Distribution](http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-statistics-toolbox/directional-distribution.htm)\n * in ArcGIS and the [QGIS Standard Deviational Ellipse Plugin](http://arken.nmbu.no/~havatv/gis/qgisplugins/SDEllipse/)\n *\n * **Bibliography**\n *\n * • Robert S. Yuill, “The Standard Deviational Ellipse; An Updated Tool for\n * Spatial Description,” _Geografiska Annaler_ 53, no. 1 (1971): 28–39,\n * doi:{@link https://doi.org/10.2307/490885|10.2307/490885}.\n *\n * • Paul Hanly Furfey, “A Note on Lefever’s “Standard Deviational Ellipse,”\n * _American Journal of Sociology_ 33, no. 1 (1927): 94—98,\n * doi:{@link https://doi.org/10.1086/214336|10.1086/214336}.\n *\n *\n * @name standardDeviationalEllipse\n * @param {FeatureCollection<Point>} points GeoJSON points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.weight] the property name used to weight the center\n * @param {number} [options.steps=64] number of steps for the polygon\n * @param {Object} [options.properties={}] properties to pass to the resulting ellipse\n * @returns {Feature<Polygon>} an elliptical Polygon that includes approximately 1 SD of the dataset within it.\n * @example\n *\n * var bbox = [-74, 40.72, -73.98, 40.74];\n * var points = turf.randomPoint(400, {bbox: bbox});\n * var sdEllipse = turf.standardDeviationalEllipse(points);\n *\n * //addToMap\n * var addToMap = [points, sdEllipse];\n *\n */\nfunction standardDeviationalEllipse(points, options) {\n  // Optional params\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var steps = options.steps || 64;\n  var weightTerm = options.weight;\n  var properties = options.properties || {};\n\n  // Validation:\n  if (!isNumber(steps)) throw new Error(\"steps must be a number\");\n  if (!isObject(properties)) throw new Error(\"properties must be a number\");\n\n  // Calculate mean center & number of features:\n  var numberOfFeatures = coordAll(points).length;\n  var meanCenter = centerMean(points, { weight: weightTerm });\n\n  // Calculate angle of rotation:\n  // [X, Y] = mean center of all [x, y].\n  // theta = arctan( (A + B) / C )\n  // A = sum((x - X)^2) - sum((y - Y)^2)\n  // B = sqrt(A^2 + 4(sum((x - X)(y - Y))^2))\n  // C = 2(sum((x - X)(y - Y)))\n\n  var xDeviationSquaredSum = 0;\n  var yDeviationSquaredSum = 0;\n  var xyDeviationSum = 0;\n\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    xDeviationSquaredSum += Math.pow(deviation.x, 2) * weight;\n    yDeviationSquaredSum += Math.pow(deviation.y, 2) * weight;\n    xyDeviationSum += deviation.x * deviation.y * weight;\n  });\n\n  var bigA = xDeviationSquaredSum - yDeviationSquaredSum;\n  var bigB = Math.sqrt(Math.pow(bigA, 2) + 4 * Math.pow(xyDeviationSum, 2));\n  var bigC = 2 * xyDeviationSum;\n  var theta = Math.atan((bigA + bigB) / bigC);\n  var thetaDeg = (theta * 180) / Math.PI;\n\n  // Calculate axes:\n  // sigmaX = sqrt((1 / n - 2) * sum((((x - X) * cos(theta)) - ((y - Y) * sin(theta)))^2))\n  // sigmaY = sqrt((1 / n - 2) * sum((((x - X) * sin(theta)) - ((y - Y) * cos(theta)))^2))\n  var sigmaXsum = 0;\n  var sigmaYsum = 0;\n  var weightsum = 0;\n  featureEach(points, function (point) {\n    var weight = point.properties[weightTerm] || 1;\n    var deviation = getDeviations(getCoords(point), getCoords(meanCenter));\n    sigmaXsum +=\n      Math.pow(\n        deviation.x * Math.cos(theta) - deviation.y * Math.sin(theta),\n        2\n      ) * weight;\n    sigmaYsum +=\n      Math.pow(\n        deviation.x * Math.sin(theta) + deviation.y * Math.cos(theta),\n        2\n      ) * weight;\n    weightsum += weight;\n  });\n\n  var sigmaX = Math.sqrt((2 * sigmaXsum) / weightsum);\n  var sigmaY = Math.sqrt((2 * sigmaYsum) / weightsum);\n\n  var theEllipse = ellipse(meanCenter, sigmaX, sigmaY, {\n    units: \"degrees\",\n    angle: thetaDeg,\n    steps: steps,\n    properties: properties,\n  });\n  var pointsWithinEllipse = pointsWithinPolygon(\n    points,\n    featureCollection([theEllipse])\n  );\n  var standardDeviationalEllipseProperties = {\n    meanCenterCoordinates: getCoords(meanCenter),\n    semiMajorAxis: sigmaX,\n    semiMinorAxis: sigmaY,\n    numberOfFeatures: numberOfFeatures,\n    angle: thetaDeg,\n    percentageWithinEllipse:\n      (100 * coordAll(pointsWithinEllipse).length) / numberOfFeatures,\n  };\n  theEllipse.properties.standardDeviationalEllipse =\n    standardDeviationalEllipseProperties;\n\n  return theEllipse;\n}\n\n/**\n * Get x_i - X and y_i - Y\n *\n * @private\n * @param {Array} coordinates Array of [x_i, y_i]\n * @param {Array} center Array of [X, Y]\n * @returns {Object} { x: n, y: m }\n */\nfunction getDeviations(coordinates, center) {\n  return {\n    x: coordinates[0] - center[0],\n    y: coordinates[1] - center[1],\n  };\n}\n\nexport { standardDeviationalEllipse };\nexport default standardDeviationalEllipse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}