{"ast":null,"code":"function pointInPolygon(p, polygon) {\n  var i = 0;\n  var ii = 0;\n  var k = 0;\n  var f = 0;\n  var u1 = 0;\n  var v1 = 0;\n  var u2 = 0;\n  var v2 = 0;\n  var currentP = null;\n  var nextP = null;\n  var x = p[0];\n  var y = p[1];\n  var numContours = polygon.length;\n  for (i; i < numContours; i++) {\n    ii = 0;\n    var contourLen = polygon[i].length - 1;\n    var contour = polygon[i];\n    currentP = contour[0];\n    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {\n      throw new Error('First and last coordinates in a ring must be the same');\n    }\n    u1 = currentP[0] - x;\n    v1 = currentP[1] - y;\n    for (ii; ii < contourLen; ii++) {\n      nextP = contour[ii + 1];\n      v2 = nextP[1] - y;\n      if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {\n        currentP = nextP;\n        v1 = v2;\n        u1 = currentP[0] - x;\n        continue;\n      }\n      u2 = nextP[0] - p[0];\n      if (v2 > 0 && v1 <= 0) {\n        f = u1 * v2 - u2 * v1;\n        if (f > 0) {\n          k = k + 1;\n        } else if (f === 0) {\n          return 0;\n        }\n      } else if (v1 > 0 && v2 <= 0) {\n        f = u1 * v2 - u2 * v1;\n        if (f < 0) {\n          k = k + 1;\n        } else if (f === 0) {\n          return 0;\n        }\n      } else if (v2 === 0 && v1 < 0) {\n        f = u1 * v2 - u2 * v1;\n        if (f === 0) {\n          return 0;\n        }\n      } else if (v1 === 0 && v2 < 0) {\n        f = u1 * v2 - u2 * v1;\n        if (f === 0) {\n          return 0;\n        }\n      } else if (v1 === 0 && v2 === 0) {\n        if (u2 <= 0 && u1 >= 0) {\n          return 0;\n        } else if (u1 <= 0 && u2 >= 0) {\n          return 0;\n        }\n      }\n      currentP = nextP;\n      v1 = v2;\n      u1 = u2;\n    }\n  }\n  if (k % 2 === 0) {\n    return false;\n  }\n  return true;\n}\nexport default pointInPolygon;","map":{"version":3,"names":["pointInPolygon","p","polygon","i","ii","k","f","u1","v1","u2","v2","currentP","nextP","x","y","numContours","length","contourLen","contour","Error"],"sources":["/Users/minaguevara/Desktop/Dev/websites/rus-mapa/node_modules/point-in-polygon-hao/dist/pointInPolygon.mjs"],"sourcesContent":["function pointInPolygon(p, polygon) {\n    var i = 0;\n    var ii = 0;\n    var k = 0;\n    var f = 0;\n    var u1 = 0;\n    var v1 = 0;\n    var u2 = 0;\n    var v2 = 0;\n    var currentP = null;\n    var nextP = null;\n\n    var x = p[0];\n    var y = p[1];\n\n    var numContours = polygon.length;\n    for (i; i < numContours; i++) {\n        ii = 0;\n        var contourLen = polygon[i].length - 1;\n        var contour = polygon[i];\n\n        currentP = contour[0];\n        if (currentP[0] !== contour[contourLen][0] &&\n            currentP[1] !== contour[contourLen][1]) {\n            throw new Error('First and last coordinates in a ring must be the same')\n        }\n\n        u1 = currentP[0] - x;\n        v1 = currentP[1] - y;\n\n        for (ii; ii < contourLen; ii++) {\n            nextP = contour[ii + 1];\n\n            v2 = nextP[1] - y;\n\n            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {\n                currentP = nextP;\n                v1 = v2;\n                u1 = currentP[0] - x;\n                continue\n            }\n\n            u2 = nextP[0] - p[0];\n\n            if (v2 > 0 && v1 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f > 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v1 > 0 && v2 <= 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f < 0) { k = k + 1; }\n                else if (f === 0) { return 0 }\n            } else if (v2 === 0 && v1 < 0) {\n                f = (u1 * v2) - (u2 * v1);\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 < 0) {\n                f = u1 * v2 - u2 * v1;\n                if (f === 0) { return 0 }\n            } else if (v1 === 0 && v2 === 0) {\n                if (u2 <= 0 && u1 >= 0) {\n                    return 0\n                } else if (u1 <= 0 && u2 >= 0) {\n                    return 0\n                }\n            }\n            currentP = nextP;\n            v1 = v2;\n            u1 = u2;\n        }\n    }\n\n    if (k % 2 === 0) { return false }\n    return true\n}\n\nexport default pointInPolygon;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}