{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.js\nimport { distance } from \"@turf/distance\";\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [west, verticalMidpoint - (east - west) / 2, east, verticalMidpoint + (east - west) / 2];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [horizontalMidpoint - (north - south) / 2, south, horizontalMidpoint + (north - south) / 2, north];\n  }\n}\n__name(square, \"square\");\nvar turf_square_default = square;\nexport { turf_square_default as default, square };","map":{"version":3,"names":["distance","square","bbox","west","south","east","north","horizontalDistance","slice","verticalDistance","verticalMidpoint","horizontalMidpoint","__name","turf_square_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/square/index.js"],"sourcesContent":["import { distance } from \"@turf/distance\";\n\n/**\n * Takes a bounding box and calculates the minimum square bounding box that\n * would contain the input.\n *\n * @name square\n * @param {BBox} bbox extent in [west, south, east, north] order\n * @returns {BBox} a square surrounding `bbox`\n * @example\n * var bbox = [-20, -20, -15, 0];\n * var squared = turf.square(bbox);\n *\n * //addToMap\n * var addToMap = [turf.bboxPolygon(bbox), turf.bboxPolygon(squared)]\n */\nfunction square(bbox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  var horizontalDistance = distance(bbox.slice(0, 2), [east, south]);\n  var verticalDistance = distance(bbox.slice(0, 2), [west, north]);\n  if (horizontalDistance >= verticalDistance) {\n    var verticalMidpoint = (south + north) / 2;\n    return [\n      west,\n      verticalMidpoint - (east - west) / 2,\n      east,\n      verticalMidpoint + (east - west) / 2,\n    ];\n  } else {\n    var horizontalMidpoint = (west + east) / 2;\n    return [\n      horizontalMidpoint - (north - south) / 2,\n      south,\n      horizontalMidpoint + (north - south) / 2,\n      north,\n    ];\n  }\n}\n\nexport { square };\nexport default square;\n"],"mappings":";;;;;;;AAAA,SAASA,QAAA,QAAgB;AAgBzB,SAASC,OAAOC,IAAA,EAAM;EACpB,IAAIC,IAAA,GAAOD,IAAA,CAAK,CAAC;EACjB,IAAIE,KAAA,GAAQF,IAAA,CAAK,CAAC;EAClB,IAAIG,IAAA,GAAOH,IAAA,CAAK,CAAC;EACjB,IAAII,KAAA,GAAQJ,IAAA,CAAK,CAAC;EAElB,IAAIK,kBAAA,GAAqBP,QAAA,CAASE,IAAA,CAAKM,KAAA,CAAM,GAAG,CAAC,GAAG,CAACH,IAAA,EAAMD,KAAK,CAAC;EACjE,IAAIK,gBAAA,GAAmBT,QAAA,CAASE,IAAA,CAAKM,KAAA,CAAM,GAAG,CAAC,GAAG,CAACL,IAAA,EAAMG,KAAK,CAAC;EAC/D,IAAIC,kBAAA,IAAsBE,gBAAA,EAAkB;IAC1C,IAAIC,gBAAA,IAAoBN,KAAA,GAAQE,KAAA,IAAS;IACzC,OAAO,CACLH,IAAA,EACAO,gBAAA,IAAoBL,IAAA,GAAOF,IAAA,IAAQ,GACnCE,IAAA,EACAK,gBAAA,IAAoBL,IAAA,GAAOF,IAAA,IAAQ,EACrC;EACF,OAAO;IACL,IAAIQ,kBAAA,IAAsBR,IAAA,GAAOE,IAAA,IAAQ;IACzC,OAAO,CACLM,kBAAA,IAAsBL,KAAA,GAAQF,KAAA,IAAS,GACvCA,KAAA,EACAO,kBAAA,IAAsBL,KAAA,GAAQF,KAAA,IAAS,GACvCE,KAAA,CACF;EACF;AACF;AAzBSM,MAAA,CAAAX,MAAA;AA4BT,IAAOY,mBAAA,GAAQZ,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}