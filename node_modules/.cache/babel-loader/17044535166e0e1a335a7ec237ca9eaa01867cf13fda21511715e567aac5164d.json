{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.js\nimport { clone } from \"@turf/clone\";\nimport { center } from \"@turf/center\";\nimport { centroid } from \"@turf/centroid\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { coordEach, featureEach } from \"@turf/meta\";\nimport { point, isObject } from \"@turf/helpers\";\nimport { getCoord, getCoords, getType } from \"@turf/invariant\";\nfunction transformScale(geojson, factor, options) {\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var origin = options.origin;\n  var mutate = options.mutate;\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor <= 0) throw new Error(\"invalid factor\");\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\n  if (mutate !== true) geojson = clone(geojson);\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  }\n  return scale(geojson, factor, origin);\n}\n__name(transformScale, \"transformScale\");\nfunction scale(feature, factor, origin) {\n  var isPoint = getType(feature) === \"Point\";\n  origin = defineOrigin(feature, origin);\n  if (factor === 1 || isPoint) return feature;\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n  delete feature.bbox;\n  return feature;\n}\n__name(scale, \"scale\");\nfunction defineOrigin(geojson, origin) {\n  if (origin === void 0 || origin === null) origin = \"centroid\";\n  if (Array.isArray(origin) || typeof origin === \"object\") return getCoord(origin);\n  var bbox = geojson.bbox ? geojson.bbox : turfBBox(geojson, {\n    recalculate: true\n  });\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  switch (origin) {\n    case \"sw\":\n    case \"southwest\":\n    case \"westsouth\":\n    case \"bottomleft\":\n      return point([west, south]);\n    case \"se\":\n    case \"southeast\":\n    case \"eastsouth\":\n    case \"bottomright\":\n      return point([east, south]);\n    case \"nw\":\n    case \"northwest\":\n    case \"westnorth\":\n    case \"topleft\":\n      return point([west, north]);\n    case \"ne\":\n    case \"northeast\":\n    case \"eastnorth\":\n    case \"topright\":\n      return point([east, north]);\n    case \"center\":\n      return center(geojson);\n    case void 0:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n    default:\n      throw new Error(\"invalid origin\");\n  }\n}\n__name(defineOrigin, \"defineOrigin\");\nvar turf_transform_scale_default = transformScale;\nexport { turf_transform_scale_default as default, transformScale };","map":{"version":3,"names":["clone","center","centroid","bbox","turfBBox","rhumbBearing","rhumbDistance","rhumbDestination","coordEach","featureEach","point","isObject","getCoord","getCoords","getType","transformScale","geojson","factor","options","Error","origin","mutate","originIsPoint","Array","isArray","type","feature","index","features","scale","__name","isPoint","defineOrigin","coord","originalDistance","bearing","newDistance","newCoord","length","recalculate","west","south","east","north","turf_transform_scale_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/transform-scale/index.js"],"sourcesContent":["import { clone } from \"@turf/clone\";\nimport { center } from \"@turf/center\";\nimport { centroid } from \"@turf/centroid\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nimport { rhumbDistance } from \"@turf/rhumb-distance\";\nimport { rhumbDestination } from \"@turf/rhumb-destination\";\nimport { coordEach, featureEach } from \"@turf/meta\";\nimport { point, isObject } from \"@turf/helpers\";\nimport { getCoord, getCoords, getType } from \"@turf/invariant\";\n\n/**\n * Scale a GeoJSON from a given point by a factor of scaling (ex: factor=2 would make the GeoJSON 200% larger).\n * If a FeatureCollection is provided, the origin point will be calculated based on each individual Feature.\n *\n * @name transformScale\n * @param {GeoJSON} geojson GeoJSON to be scaled\n * @param {number} factor of scaling, positive values greater than 0. Numbers between 0 and 1 will shrink the geojson, numbers greater than 1 will expand it, a factor of 1 will not change the geojson.\n * @param {Object} [options={}] Optional parameters\n * @param {string|Coord} [options.origin='centroid'] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} scaled GeoJSON\n * @example\n * var poly = turf.polygon([[[0,29],[3.5,29],[2.5,32],[0,29]]]);\n * var scaledPoly = turf.transformScale(poly, 3);\n *\n * //addToMap\n * var addToMap = [poly, scaledPoly];\n * scaledPoly.properties = {stroke: '#F00', 'stroke-width': 4};\n */\nfunction transformScale(geojson, factor, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var origin = options.origin;\n  var mutate = options.mutate;\n\n  // Input validation\n  if (!geojson) throw new Error(\"geojson required\");\n  if (typeof factor !== \"number\" || factor <= 0)\n    throw new Error(\"invalid factor\");\n  var originIsPoint = Array.isArray(origin) || typeof origin === \"object\";\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  // Scale each Feature separately\n  if (geojson.type === \"FeatureCollection\" && !originIsPoint) {\n    featureEach(geojson, function (feature, index) {\n      geojson.features[index] = scale(feature, factor, origin);\n    });\n    return geojson;\n  }\n  // Scale Feature/Geometry\n  return scale(geojson, factor, origin);\n}\n\n/**\n * Scale Feature/Geometry\n *\n * @private\n * @param {Feature|Geometry} feature GeoJSON Feature/Geometry\n * @param {number} factor of scaling, positive or negative values greater than 0\n * @param {string|Coord} [origin=\"centroid\"] Point from which the scaling will occur (string options: sw/se/nw/ne/center/centroid)\n * @returns {Feature|Geometry} scaled GeoJSON Feature/Geometry\n */\nfunction scale(feature, factor, origin) {\n  // Default params\n  var isPoint = getType(feature) === \"Point\";\n  origin = defineOrigin(feature, origin);\n\n  // Shortcut no-scaling\n  if (factor === 1 || isPoint) return feature;\n\n  // Scale each coordinate\n  coordEach(feature, function (coord) {\n    var originalDistance = rhumbDistance(origin, coord);\n    var bearing = rhumbBearing(origin, coord);\n    var newDistance = originalDistance * factor;\n    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing));\n    coord[0] = newCoord[0];\n    coord[1] = newCoord[1];\n    if (coord.length === 3) coord[2] *= factor;\n  });\n\n  delete feature.bbox;\n\n  return feature;\n}\n\n/**\n * Define Origin\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON\n * @param {string|Coord} origin sw/se/nw/ne/center/centroid\n * @returns {Feature<Point>} Point origin\n */\nfunction defineOrigin(geojson, origin) {\n  // Default params\n  if (origin === undefined || origin === null) origin = \"centroid\";\n\n  // Input Coord\n  if (Array.isArray(origin) || typeof origin === \"object\")\n    return getCoord(origin);\n\n  // Define BBox\n  var bbox = geojson.bbox\n    ? geojson.bbox\n    : turfBBox(geojson, { recalculate: true });\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n\n  switch (origin) {\n    case \"sw\":\n    case \"southwest\":\n    case \"westsouth\":\n    case \"bottomleft\":\n      return point([west, south]);\n    case \"se\":\n    case \"southeast\":\n    case \"eastsouth\":\n    case \"bottomright\":\n      return point([east, south]);\n    case \"nw\":\n    case \"northwest\":\n    case \"westnorth\":\n    case \"topleft\":\n      return point([west, north]);\n    case \"ne\":\n    case \"northeast\":\n    case \"eastnorth\":\n    case \"topright\":\n      return point([east, north]);\n    case \"center\":\n      return center(geojson);\n    case undefined:\n    case null:\n    case \"centroid\":\n      return centroid(geojson);\n    default:\n      throw new Error(\"invalid origin\");\n  }\n}\n\nexport { transformScale };\nexport default transformScale;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}