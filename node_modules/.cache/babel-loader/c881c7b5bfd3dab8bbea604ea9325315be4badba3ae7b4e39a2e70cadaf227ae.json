{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport { distance as getDistance } from \"@turf/distance\";\nimport { convertLength, feature, lineString, point } from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport { rhumbDistance as getPlanarDistance } from \"@turf/rhumb-distance\";\nfunction pointToLineDistance(pt, line, options = {}) {\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n  if (!options.units) {\n    options.units = \"kilometers\";\n  }\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n  let distance = Infinity;\n  const p = pt.geometry.coordinates;\n  segmentEach(line, segment => {\n    const a = segment.geometry.coordinates[0];\n    const b = segment.geometry.coordinates[1];\n    const d = distanceToSegment(p, a, b, options);\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return convertLength(distance, \"degrees\", options.units);\n}\n__name(pointToLineDistance, \"pointToLineDistance\");\nfunction distanceToSegment(p, a, b, options) {\n  const v = [b[0] - a[0], b[1] - a[1]];\n  const w = [p[0] - a[0], p[1] - a[1]];\n  const c1 = dot(w, v);\n  if (c1 <= 0) {\n    return calcDistance(p, a, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n  const c2 = dot(v, v);\n  if (c2 <= c1) {\n    return calcDistance(p, b, {\n      method: options.method,\n      units: \"degrees\"\n    });\n  }\n  const b2 = c1 / c2;\n  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, {\n    method: options.method,\n    units: \"degrees\"\n  });\n}\n__name(distanceToSegment, \"distanceToSegment\");\nfunction dot(u, v) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n__name(dot, \"dot\");\nfunction calcDistance(a, b, options) {\n  return options.method === \"planar\" ? getPlanarDistance(a, b, options) : getDistance(a, b, options);\n}\n__name(calcDistance, \"calcDistance\");\nvar turf_point_to_line_distance_default = pointToLineDistance;\nexport { turf_point_to_line_distance_default as default, pointToLineDistance };","map":{"version":3,"names":["distance","getDistance","convertLength","feature","lineString","point","featureOf","segmentEach","rhumbDistance","getPlanarDistance","pointToLineDistance","pt","line","options","method","units","Error","Array","isArray","type","Infinity","p","geometry","coordinates","segment","a","b","d","distanceToSegment","__name","v","w","c1","dot","calcDistance","c2","b2","Pb","u","turf_point_to_line_distance_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/point-to-line-distance/index.ts"],"sourcesContent":["// Taken from http://geomalgorithms.com/a02-_lines.html\nimport { Feature, LineString } from \"geojson\";\nimport { distance as getDistance } from \"@turf/distance\";\nimport {\n  convertLength,\n  Coord,\n  feature,\n  lineString,\n  point,\n  Units,\n} from \"@turf/helpers\";\nimport { featureOf } from \"@turf/invariant\";\nimport { segmentEach } from \"@turf/meta\";\nimport { rhumbDistance as getPlanarDistance } from \"@turf/rhumb-distance\";\n\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(\n  pt: Coord,\n  line: Feature<LineString> | LineString,\n  options: {\n    units?: Units;\n    method?: \"geodesic\" | \"planar\";\n  } = {}\n): number {\n  // Optional parameters\n  if (!options.method) {\n    options.method = \"geodesic\";\n  }\n  if (!options.units) {\n    options.units = \"kilometers\";\n  }\n\n  // validation\n  if (!pt) {\n    throw new Error(\"pt is required\");\n  }\n  if (Array.isArray(pt)) {\n    pt = point(pt);\n  } else if (pt.type === \"Point\") {\n    pt = feature(pt);\n  } else {\n    featureOf(pt, \"Point\", \"point\");\n  }\n\n  if (!line) {\n    throw new Error(\"line is required\");\n  }\n  if (Array.isArray(line)) {\n    line = lineString(line);\n  } else if (line.type === \"LineString\") {\n    line = feature(line);\n  } else {\n    featureOf(line, \"LineString\", \"line\");\n  }\n\n  let distance = Infinity;\n  const p = pt.geometry.coordinates;\n  segmentEach(line, (segment) => {\n    const a = segment!.geometry.coordinates[0];\n    const b = segment!.geometry.coordinates[1];\n    const d = distanceToSegment(p, a, b, options);\n    if (d < distance) {\n      distance = d;\n    }\n  });\n  return convertLength(distance, \"degrees\", options.units);\n}\n\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(\n  p: number[],\n  a: number[],\n  b: number[],\n  options: any\n) {\n  const v = [b[0] - a[0], b[1] - a[1]];\n  const w = [p[0] - a[0], p[1] - a[1]];\n\n  const c1 = dot(w, v);\n  if (c1 <= 0) {\n    return calcDistance(p, a, { method: options.method, units: \"degrees\" });\n  }\n  const c2 = dot(v, v);\n  if (c2 <= c1) {\n    return calcDistance(p, b, { method: options.method, units: \"degrees\" });\n  }\n  const b2 = c1 / c2;\n  const Pb = [a[0] + b2 * v[0], a[1] + b2 * v[1]];\n  return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\n}\n\nfunction dot(u: number[], v: number[]) {\n  return u[0] * v[0] + u[1] * v[1];\n}\n\nfunction calcDistance(a: number[], b: number[], options: any) {\n  return options.method === \"planar\"\n    ? getPlanarDistance(a, b, options)\n    : getDistance(a, b, options);\n}\n\nexport { pointToLineDistance };\nexport default pointToLineDistance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}