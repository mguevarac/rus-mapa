{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport polygonClipping from \"polygon-clipping\";\nimport { multiPolygon, polygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nfunction union(features, options = {}) {\n  const geoms = [];\n  geomEach(features, geom => {\n    geoms.push(geom.coordinates);\n  });\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least 2 geometries\");\n  }\n  const unioned = polygonClipping.union(geoms[0], ...geoms.slice(1));\n  if (unioned.length === 0) return null;\n  if (unioned.length === 1) return polygon(unioned[0], options.properties);else return multiPolygon(unioned, options.properties);\n}\n__name(union, \"union\");\nvar turf_union_default = union;\nexport { turf_union_default as default, union };","map":{"version":3,"names":["polygonClipping","multiPolygon","polygon","geomEach","union","features","options","geoms","geom","push","coordinates","length","Error","unioned","slice","properties","__name","turf_union_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/union/index.ts"],"sourcesContent":["import polygonClipping from \"polygon-clipping\";\nimport { multiPolygon, polygon } from \"@turf/helpers\";\nimport { geomEach } from \"@turf/meta\";\nimport {\n  FeatureCollection,\n  Feature,\n  Polygon,\n  MultiPolygon,\n  GeoJsonProperties,\n} from \"geojson\";\n\n/**\n * Takes input {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\n *\n * @name union\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon features\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] Translate Properties to output Feature\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature, or null if the inputs are empty\n * @example\n * var poly1 = turf.polygon([[\n *     [-82.574787, 35.594087],\n *     [-82.574787, 35.615581],\n *     [-82.545261, 35.615581],\n *     [-82.545261, 35.594087],\n *     [-82.574787, 35.594087]\n * ]], {\"fill\": \"#0f0\"});\n * var poly2 = turf.polygon([[\n *     [-82.560024, 35.585153],\n *     [-82.560024, 35.602602],\n *     [-82.52964, 35.602602],\n *     [-82.52964, 35.585153],\n *     [-82.560024, 35.585153]\n * ]], {\"fill\": \"#00f\"});\n *\n * var union = turf.union(turf.featureCollection([poly1, poly2]));\n *\n * //addToMap\n * var addToMap = [poly1, poly2, union];\n */\nfunction union<P extends GeoJsonProperties = GeoJsonProperties>(\n  features: FeatureCollection<Polygon | MultiPolygon>,\n  options: { properties?: P } = {}\n): Feature<Polygon | MultiPolygon, P> | null {\n  const geoms: polygonClipping.Geom[] = [];\n  geomEach(features, (geom) => {\n    geoms.push(geom.coordinates as polygonClipping.Geom);\n  });\n\n  if (geoms.length < 2) {\n    throw new Error(\"Must have at least 2 geometries\");\n  }\n\n  const unioned = polygonClipping.union(geoms[0], ...geoms.slice(1));\n  if (unioned.length === 0) return null;\n  if (unioned.length === 1) return polygon(unioned[0], options.properties);\n  else return multiPolygon(unioned, options.properties);\n}\n\nexport { union };\nexport default union;\n"],"mappings":";;;;;;;AAAA,OAAOA,eAAA,MAAqB;AAC5B,SAASC,YAAA,EAAcC,OAAA,QAAe;AACtC,SAASC,QAAA,QAAgB;AAsCzB,SAASC,MACPC,QAAA,EACAC,OAAA,GAA8B,CAAC,GACY;EAC3C,MAAMC,KAAA,GAAgC,EAAC;EACvCJ,QAAA,CAASE,QAAA,EAAWG,IAAA,IAAS;IAC3BD,KAAA,CAAME,IAAA,CAAKD,IAAA,CAAKE,WAAmC;EACrD,CAAC;EAED,IAAIH,KAAA,CAAMI,MAAA,GAAS,GAAG;IACpB,MAAM,IAAIC,KAAA,CAAM,iCAAiC;EACnD;EAEA,MAAMC,OAAA,GAAUb,eAAA,CAAgBI,KAAA,CAAMG,KAAA,CAAM,CAAC,GAAG,GAAGA,KAAA,CAAMO,KAAA,CAAM,CAAC,CAAC;EACjE,IAAID,OAAA,CAAQF,MAAA,KAAW,GAAG,OAAO;EACjC,IAAIE,OAAA,CAAQF,MAAA,KAAW,GAAG,OAAOT,OAAA,CAAQW,OAAA,CAAQ,CAAC,GAAGP,OAAA,CAAQS,UAAU,OAClE,OAAOd,YAAA,CAAaY,OAAA,EAASP,OAAA,CAAQS,UAAU;AACtD;AAjBSC,MAAA,CAAAZ,KAAA;AAoBT,IAAOa,kBAAA,GAAQb,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}