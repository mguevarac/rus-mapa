{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineIntersect as lineIntersects } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nfunction nearestPointOnLine(lines, pt, options = {}) {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n  let closestPt = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    location: -1\n  });\n  let length = 0;\n  flattenEach(lines, function (line) {\n    const coords = getCoords(line);\n    for (let i = 0; i < coords.length - 1; i++) {\n      const start = point(coords[i]);\n      start.properties.dist = distance(pt, start, options);\n      const stop = point(coords[i + 1]);\n      stop.properties.dist = distance(pt, stop, options);\n      const sectionLength = distance(start, stop, options);\n      const heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n      const direction = bearing(start, stop);\n      const perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);\n      const perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);\n      const intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n      let intersectPt;\n      if (intersect.features.length > 0 && intersect.features[0]) {\n        intersectPt = __spreadProps(__spreadValues({}, intersect.features[0]), {\n          properties: {\n            dist: distance(pt, intersect.features[0], options),\n            location: length + distance(start, intersect.features[0], options)\n          }\n        });\n      }\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, start), {\n          properties: __spreadProps(__spreadValues({}, start.properties), {\n            index: i,\n            location: length\n          })\n        });\n      }\n      if (stop.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, stop), {\n          properties: __spreadProps(__spreadValues({}, stop.properties), {\n            index: i + 1,\n            location: length + sectionLength\n          })\n        });\n      }\n      if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n        closestPt = __spreadProps(__spreadValues({}, intersectPt), {\n          properties: __spreadProps(__spreadValues({}, intersectPt.properties), {\n            index: i\n          })\n        });\n      }\n      length += sectionLength;\n    }\n  });\n  return closestPt;\n}\n__name(nearestPointOnLine, \"nearestPointOnLine\");\nvar turf_nearest_point_on_line_default = nearestPointOnLine;\nexport { turf_nearest_point_on_line_default as default, nearestPointOnLine };","map":{"version":3,"names":["bearing","distance","destination","lineIntersect","lineIntersects","flattenEach","point","lineString","getCoords","nearestPointOnLine","lines","pt","options","Error","closestPt","Infinity","dist","index","location","length","line","coords","i","start","properties","stop","sectionLength","heightDistance","Math","max","direction","perpendicularPt1","perpendicularPt2","intersect","geometry","coordinates","intersectPt","features","__spreadProps","__spreadValues","__name","turf_nearest_point_on_line_default"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/nearest-point-on-line/index.ts"],"sourcesContent":["import { Feature, Point, LineString, MultiLineString } from \"geojson\";\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineIntersect as lineIntersects } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString, Coord, Units } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(lines, function (line: any) {\n    const coords: any = getCoords(line);\n\n    for (let i = 0; i < coords.length - 1; i++) {\n      //start\n      const start: Feature<Point, { dist: number }> = point(coords[i]);\n      start.properties.dist = distance(pt, start, options);\n      //stop\n      const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n      stop.properties.dist = distance(pt, stop, options);\n      // sectionLength\n      const sectionLength = distance(start, stop, options);\n      //perpendicular\n      const heightDistance = Math.max(\n        start.properties.dist,\n        stop.properties.dist\n      );\n      const direction = bearing(start, stop);\n      const perpendicularPt1 = destination(\n        pt,\n        heightDistance,\n        direction + 90,\n        options\n      );\n      const perpendicularPt2 = destination(\n        pt,\n        heightDistance,\n        direction - 90,\n        options\n      );\n      const intersect = lineIntersects(\n        lineString([\n          perpendicularPt1.geometry.coordinates,\n          perpendicularPt2.geometry.coordinates,\n        ]),\n        lineString([start.geometry.coordinates, stop.geometry.coordinates])\n      );\n      let intersectPt:\n        | Feature<Point, { dist: number; location: number }>\n        | undefined;\n\n      if (intersect.features.length > 0 && intersect.features[0]) {\n        intersectPt = {\n          ...intersect.features[0],\n          properties: {\n            dist: distance(pt, intersect.features[0], options),\n            location: length + distance(start, intersect.features[0], options),\n          },\n        };\n      }\n\n      if (start.properties.dist < closestPt.properties.dist) {\n        closestPt = {\n          ...start,\n          properties: { ...start.properties, index: i, location: length },\n        };\n      }\n\n      if (stop.properties.dist < closestPt.properties.dist) {\n        closestPt = {\n          ...stop,\n          properties: {\n            ...stop.properties,\n            index: i + 1,\n            location: length + sectionLength,\n          },\n        };\n      }\n\n      if (\n        intersectPt &&\n        intersectPt.properties.dist < closestPt.properties.dist\n      ) {\n        closestPt = {\n          ...intersectPt,\n          properties: { ...intersectPt.properties, index: i },\n        };\n      }\n      // update length\n      length += sectionLength;\n    }\n  });\n\n  return closestPt;\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}