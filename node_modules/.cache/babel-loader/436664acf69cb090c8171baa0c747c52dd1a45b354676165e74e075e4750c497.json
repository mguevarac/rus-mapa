{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", {\n  value,\n  configurable: true\n});\n\n// lib/geojson-equality.ts\nimport equal from \"deep-equal\";\nvar _GeojsonEquality = class _GeojsonEquality {\n  constructor(opts) {\n    this.direction = false;\n    this.compareProperties = true;\n    var _a, _b, _c;\n    this.precision = 10 ** -((_a = opts == null ? void 0 : opts.precision) != null ? _a : 17);\n    this.direction = (_b = opts == null ? void 0 : opts.direction) != null ? _b : false;\n    this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;\n  }\n  compare(g1, g2) {\n    if (g1.type !== g2.type) {\n      return false;\n    }\n    if (!sameLength(g1, g2)) {\n      return false;\n    }\n    switch (g1.type) {\n      case \"Point\":\n        return this.compareCoord(g1.coordinates, g2.coordinates);\n      case \"LineString\":\n        return this.compareLine(g1.coordinates, g2.coordinates);\n      case \"Polygon\":\n        return this.comparePolygon(g1, g2);\n      case \"GeometryCollection\":\n        return this.compareGeometryCollection(g1, g2);\n      case \"Feature\":\n        return this.compareFeature(g1, g2);\n      case \"FeatureCollection\":\n        return this.compareFeatureCollection(g1, g2);\n      default:\n        if (g1.type.startsWith(\"Multi\")) {\n          const g1s = explode(g1);\n          const g2s = explode(g2);\n          return g1s.every(g1part => g2s.some(g2part => this.compare(g1part, g2part)));\n        }\n    }\n    return false;\n  }\n  compareCoord(c1, c2) {\n    return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);\n  }\n  compareLine(path1, path2, ind = 0, isPoly = false) {\n    if (!sameLength(path1, path2)) {\n      return false;\n    }\n    const p1 = path1;\n    let p2 = path2;\n    if (isPoly && !this.compareCoord(p1[0], p2[0])) {\n      const startIndex = this.fixStartIndex(p2, p1);\n      if (!startIndex) {\n        return false;\n      } else {\n        p2 = startIndex;\n      }\n    }\n    const sameDirection = this.compareCoord(p1[ind], p2[ind]);\n    if (this.direction || sameDirection) {\n      return this.comparePath(p1, p2);\n    } else {\n      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {\n        return this.comparePath(p1.slice().reverse(), p2);\n      }\n      return false;\n    }\n  }\n  fixStartIndex(sourcePath, targetPath) {\n    let correctPath,\n      ind = -1;\n    for (let i = 0; i < sourcePath.length; i++) {\n      if (this.compareCoord(sourcePath[i], targetPath[0])) {\n        ind = i;\n        break;\n      }\n    }\n    if (ind >= 0) {\n      correctPath = [].concat(sourcePath.slice(ind, sourcePath.length), sourcePath.slice(1, ind + 1));\n    }\n    return correctPath;\n  }\n  comparePath(p1, p2) {\n    return p1.every((c, i) => this.compareCoord(c, p2[i]));\n  }\n  comparePolygon(g1, g2) {\n    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {\n      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);\n      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);\n      return holes1.every(h1 => holes2.some(h2 => this.compareLine(h1, h2, 1, true)));\n    }\n    return false;\n  }\n  compareGeometryCollection(g1, g2) {\n    return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]));\n  }\n  compareFeature(g1, g2) {\n    return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);\n  }\n  compareFeatureCollection(g1, g2) {\n    return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i) => this.compare(f, g2.features[i]));\n  }\n  compareBBox(g1, g2) {\n    return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);\n  }\n};\n__name(_GeojsonEquality, \"GeojsonEquality\");\nvar GeojsonEquality = _GeojsonEquality;\nfunction sameLength(g1, g2) {\n  return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;\n}\n__name(sameLength, \"sameLength\");\nfunction explode(g) {\n  return g.coordinates.map(part => ({\n    type: g.type.replace(\"Multi\", \"\"),\n    coordinates: part\n  }));\n}\n__name(explode, \"explode\");\n\n// index.ts\nvar earthRadius = 63710088e-1;\nvar factors = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1e3,\n  kilometres: earthRadius / 1e3,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1e3,\n  millimetres: earthRadius * 1e3,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936\n};\nvar areaFactors = {\n  acres: 247105e-9,\n  centimeters: 1e4,\n  centimetres: 1e4,\n  feet: 10.763910417,\n  hectares: 1e-4,\n  inches: 1550.003100006,\n  kilometers: 1e-6,\n  kilometres: 1e-6,\n  meters: 1,\n  metres: 1,\n  miles: 386e-9,\n  nauticalmiles: 29155334959812285e-23,\n  millimeters: 1e6,\n  millimetres: 1e6,\n  yards: 1.195990046\n};\nfunction feature(geom, properties, options = {}) {\n  const feat = {\n    type: \"Feature\"\n  };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n__name(feature, \"feature\");\nfunction geometry(type, coordinates, _options = {}) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n__name(geometry, \"geometry\");\nfunction point(coordinates, properties, options = {}) {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n  const geom = {\n    type: \"Point\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(point, \"point\");\nfunction points(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return point(coords, properties);\n  }), options);\n}\n__name(points, \"points\");\nfunction polygon(coordinates, properties, options = {}) {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    }\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom = {\n    type: \"Polygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(polygon, \"polygon\");\nfunction polygons(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return polygon(coords, properties);\n  }), options);\n}\n__name(polygons, \"polygons\");\nfunction lineString(coordinates, properties, options = {}) {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom = {\n    type: \"LineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(lineString, \"lineString\");\nfunction lineStrings(coordinates, properties, options = {}) {\n  return featureCollection(coordinates.map(coords => {\n    return lineString(coords, properties);\n  }), options);\n}\n__name(lineStrings, \"lineStrings\");\nfunction featureCollection(features, options = {}) {\n  const fc = {\n    type: \"FeatureCollection\"\n  };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n__name(featureCollection, \"featureCollection\");\nfunction multiLineString(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiLineString\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(multiLineString, \"multiLineString\");\nfunction multiPoint(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPoint\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(multiPoint, \"multiPoint\");\nfunction multiPolygon(coordinates, properties, options = {}) {\n  const geom = {\n    type: \"MultiPolygon\",\n    coordinates\n  };\n  return feature(geom, properties, options);\n}\n__name(multiPolygon, \"multiPolygon\");\nfunction geometryCollection(geometries, properties, options = {}) {\n  const geom = {\n    type: \"GeometryCollection\",\n    geometries\n  };\n  return feature(geom, properties, options);\n}\n__name(geometryCollection, \"geometryCollection\");\nfunction round(num, precision = 0) {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n__name(round, \"round\");\nfunction radiansToLength(radians, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n__name(radiansToLength, \"radiansToLength\");\nfunction lengthToRadians(distance, units = \"kilometers\") {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n__name(lengthToRadians, \"lengthToRadians\");\nfunction lengthToDegrees(distance, units) {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n__name(lengthToDegrees, \"lengthToDegrees\");\nfunction bearingToAzimuth(bearing) {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n__name(bearingToAzimuth, \"bearingToAzimuth\");\nfunction radiansToDegrees(radians) {\n  const degrees = radians % (2 * Math.PI);\n  return degrees * 180 / Math.PI;\n}\n__name(radiansToDegrees, \"radiansToDegrees\");\nfunction degreesToRadians(degrees) {\n  const radians = degrees % 360;\n  return radians * Math.PI / 180;\n}\n__name(degreesToRadians, \"degreesToRadians\");\nfunction convertLength(length, originalUnit = \"kilometers\", finalUnit = \"kilometers\") {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n__name(convertLength, \"convertLength\");\nfunction convertArea(area, originalUnit = \"meters\", finalUnit = \"kilometers\") {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n  return area / startFactor * finalFactor;\n}\n__name(convertArea, \"convertArea\");\nfunction isNumber(num) {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n__name(isNumber, \"isNumber\");\nfunction isObject(input) {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n__name(isObject, \"isObject\");\nfunction validateBBox(bbox) {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach(num => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n__name(validateBBox, \"validateBBox\");\nfunction validateId(id) {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n__name(validateId, \"validateId\");\nexport { GeojsonEquality, areaFactors, bearingToAzimuth, convertArea, convertLength, degreesToRadians, earthRadius, factors, feature, featureCollection, geometry, geometryCollection, isNumber, isObject, lengthToDegrees, lengthToRadians, lineString, lineStrings, multiLineString, multiPoint, multiPolygon, point, points, polygon, polygons, radiansToDegrees, radiansToLength, round, validateBBox, validateId };","map":{"version":3,"names":["equal","_GeojsonEquality","constructor","opts","direction","compareProperties","_a","_b","_c","precision","compare","g1","g2","type","sameLength","compareCoord","coordinates","compareLine","comparePolygon","compareGeometryCollection","compareFeature","compareFeatureCollection","startsWith","g1s","explode","g2s","every","g1part","some","g2part","c1","c2","length","c","i","Math","abs","path1","path2","ind","isPoly","p1","p2","startIndex","fixStartIndex","sameDirection","comparePath","slice","reverse","sourcePath","targetPath","correctPath","concat","holes1","holes2","h1","h2","geometries","compareBBox","g","id","properties","geometry","features","f","Boolean","bbox","__name","GeojsonEquality","map","part","replace","earthRadius","factors","centimeters","centimetres","degrees","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","areaFactors","acres","hectares","feature","geom","options","feat","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","Error","Array","isArray","isNumber","points","featureCollection","coords","ring","j","polygons","lineStrings","fc","geometryCollection","round","num","multiplier","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNaN","isObject","input","validateBBox","forEach","validateId","indexOf"],"sources":["/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/helpers/lib/geojson-equality.ts","/Users/minaguevara/Desktop/Dev/web_dev/rus-map/node_modules/@turf/helpers/index.ts"],"sourcesContent":["import {\n  Feature,\n  LineString,\n  Position,\n  GeoJSON,\n  Point,\n  Polygon,\n  GeometryCollection,\n  FeatureCollection,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n} from \"geojson\";\nimport equal from \"deep-equal\";\n\n/**\n\n * GeoJSON equality checking utility.\n * Adapted from https://github.com/geosquare/geojson-equality\n *\n * @memberof helpers\n * @type {Class}\n */\nexport class GeojsonEquality {\n  private precision: number;\n  private direction = false;\n  private compareProperties = true;\n\n  constructor(opts?: {\n    precision?: number;\n    direction?: boolean;\n    compareProperties?: boolean;\n  }) {\n    this.precision = 10 ** -(opts?.precision ?? 17);\n    this.direction = opts?.direction ?? false;\n    this.compareProperties = opts?.compareProperties ?? true;\n  }\n\n  compare(g1: GeoJSON, g2: GeoJSON): boolean {\n    if (g1.type !== g2.type) {\n      return false;\n    }\n\n    if (!sameLength(g1, g2)) {\n      return false;\n    }\n\n    switch (g1.type) {\n      case \"Point\":\n        return this.compareCoord(g1.coordinates, (g2 as Point).coordinates);\n      case \"LineString\":\n        return this.compareLine(g1.coordinates, (g2 as LineString).coordinates);\n      case \"Polygon\":\n        return this.comparePolygon(g1, g2 as Polygon);\n      case \"GeometryCollection\":\n        return this.compareGeometryCollection(g1, g2 as GeometryCollection);\n      case \"Feature\":\n        return this.compareFeature(g1, g2 as Feature);\n      case \"FeatureCollection\":\n        return this.compareFeatureCollection(g1, g2 as FeatureCollection);\n      default:\n        if (g1.type.startsWith(\"Multi\")) {\n          const g1s = explode(g1);\n          const g2s = explode(\n            g2 as MultiLineString | MultiPoint | MultiPolygon\n          );\n          return g1s.every((g1part) =>\n            g2s.some((g2part) => this.compare(g1part as any, g2part as any))\n          );\n        }\n    }\n    return false;\n  }\n\n  private compareCoord(c1: Position, c2: Position) {\n    return (\n      c1.length === c2.length &&\n      c1.every((c, i) => Math.abs(c - c2[i]) < this.precision)\n    );\n  }\n\n  private compareLine(\n    path1: Position[],\n    path2: Position[],\n    ind = 0,\n    isPoly = false\n  ): boolean {\n    if (!sameLength(path1, path2)) {\n      return false;\n    }\n    const p1 = path1;\n    let p2 = path2;\n    if (isPoly && !this.compareCoord(p1[0], p2[0])) {\n      // fix start index of both to same point\n      const startIndex = this.fixStartIndex(p2, p1);\n      if (!startIndex) {\n        return false;\n      } else {\n        p2 = startIndex;\n      }\n    }\n    // for linestring ind =0 and for polygon ind =1\n    const sameDirection = this.compareCoord(p1[ind], p2[ind]);\n    if (this.direction || sameDirection) {\n      return this.comparePath(p1, p2);\n    } else {\n      if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {\n        return this.comparePath(p1.slice().reverse(), p2);\n      }\n      return false;\n    }\n  }\n\n  private fixStartIndex(sourcePath: Position[], targetPath: Position[]) {\n    //make sourcePath first point same as of targetPath\n    let correctPath,\n      ind = -1;\n    for (let i = 0; i < sourcePath.length; i++) {\n      if (this.compareCoord(sourcePath[i], targetPath[0])) {\n        ind = i;\n        break;\n      }\n    }\n    if (ind >= 0) {\n      correctPath = ([] as Position[]).concat(\n        sourcePath.slice(ind, sourcePath.length),\n        sourcePath.slice(1, ind + 1)\n      );\n    }\n    return correctPath;\n  }\n\n  private comparePath(p1: Position[], p2: Position[]) {\n    return p1.every((c, i) => this.compareCoord(c, p2[i]));\n  }\n\n  private comparePolygon(g1: Polygon, g2: Polygon) {\n    if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {\n      const holes1 = g1.coordinates.slice(1, g1.coordinates.length);\n      const holes2 = g2.coordinates.slice(1, g2.coordinates.length);\n      return holes1.every((h1) =>\n        holes2.some((h2) => this.compareLine(h1, h2, 1, true))\n      );\n    }\n    return false;\n  }\n\n  private compareGeometryCollection(\n    g1: GeometryCollection,\n    g2: GeometryCollection\n  ) {\n    return (\n      sameLength(g1.geometries, g2.geometries) &&\n      this.compareBBox(g1, g2) &&\n      g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]))\n    );\n  }\n\n  private compareFeature(g1: Feature, g2: Feature) {\n    return (\n      g1.id === g2.id &&\n      (this.compareProperties ? equal(g1.properties, g2.properties) : true) &&\n      this.compareBBox(g1, g2) &&\n      this.compare(g1.geometry, g2.geometry)\n    );\n  }\n\n  private compareFeatureCollection(\n    g1: FeatureCollection,\n    g2: FeatureCollection\n  ) {\n    return (\n      sameLength(g1.features, g2.features) &&\n      this.compareBBox(g1, g2) &&\n      g1.features.every((f, i) => this.compare(f, g2.features[i]))\n    );\n  }\n\n  private compareBBox(g1: GeoJSON, g2: GeoJSON): boolean {\n    return (\n      Boolean(!g1.bbox && !g2.bbox) ||\n      (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false)\n    );\n  }\n}\n\nfunction sameLength(g1: any, g2: any) {\n  return g1.coordinates\n    ? g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\nfunction explode(g: MultiLineString | MultiPoint | MultiPolygon) {\n  return g.coordinates.map((part) => ({\n    type: g.type.replace(\"Multi\", \"\"),\n    coordinates: part,\n  }));\n}\n","import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  GeometryCollection,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n  GeoJsonProperties,\n} from \"geojson\";\n\nimport { Id } from \"./lib/geojson.js\";\nexport * from \"./lib/geojson.js\";\nexport * from \"./lib/geojson-equality.js\";\n\n// TurfJS Combined Types\nexport type Coord = Feature<Point> | Point | Position;\n\n// TurfJS String Types\nexport type Units =\n  | \"meters\"\n  | \"metres\"\n  | \"millimeters\"\n  | \"millimetres\"\n  | \"centimeters\"\n  | \"centimetres\"\n  | \"kilometers\"\n  | \"kilometres\"\n  | \"miles\"\n  | \"nauticalmiles\"\n  | \"inches\"\n  | \"yards\"\n  | \"feet\"\n  | \"radians\"\n  | \"degrees\";\nexport type AreaUnits =\n  | Exclude<Units, \"radians\" | \"degrees\">\n  | \"acres\"\n  | \"hectares\";\nexport type Grid = \"point\" | \"square\" | \"hex\" | \"triangle\";\nexport type Corners = \"sw\" | \"se\" | \"nw\" | \"ne\" | \"center\" | \"centroid\";\n\nexport type Lines = LineString | MultiLineString | Polygon | MultiPolygon;\nexport type AllGeoJSON =\n  | Feature\n  | FeatureCollection\n  | Geometry\n  | GeometryCollection;\n\n/**\n * @module helpers\n */\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport const earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * Keys are the name of the unit, values are the number of that unit in a single radian\n *\n * @memberof helpers\n * @type {Object}\n */\nexport const factors: Record<Units, number> = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936,\n};\n\n/**\n\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport const areaFactors: Record<AreaUnits, number> = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  nauticalmiles: 2.9155334959812285e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046,\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geom: G | null,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<G, P> {\n  const feat: any = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(\n  type:\n    | \"Point\"\n    | \"LineString\"\n    | \"Polygon\"\n    | \"MultiPoint\"\n    | \"MultiLineString\"\n    | \"MultiPolygon\",\n  coordinates: any[],\n  _options: Record<string, never> = {}\n) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Point, P> {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  const geom: Point = {\n    type: \"Point\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Point, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Polygon, P> {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom: Polygon = {\n    type: \"Polygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Polygon, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<LineString, P> {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom: LineString = {\n    type: \"LineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<LineString, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  features: Array<Feature<G, P>>,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<G, P> {\n  const fc: any = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiLineString, P> {\n  const geom: MultiLineString = {\n    type: \"MultiLineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPoint, P> {\n  const geom: MultiPoint = {\n    type: \"MultiPoint\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPolygon, P> {\n  const geom: MultiPolygon = {\n    type: \"MultiPolygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geometries: Array<\n    Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon\n  >,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<GeometryCollection, P> {\n  const geom: GeometryCollection = {\n    type: \"GeometryCollection\",\n    geometries,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num: number, precision = 0): number {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(\n  radians: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(\n  distance: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance: number, units?: Units): number {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing: number): number {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  const degrees = radians % (2 * Math.PI);\n  return (degrees * 180) / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees: number): number {\n  const radians = degrees % 360;\n  return (radians * Math.PI) / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(\n  length: number,\n  originalUnit: Units = \"kilometers\",\n  finalUnit: Units = \"kilometers\"\n): number {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(\n  area: number,\n  originalUnit: AreaUnits = \"meters\",\n  finalUnit: AreaUnits = \"kilometers\"\n): number {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num: any): boolean {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false, including false for Arrays and Functions\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input: any): boolean {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws {Error} if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox: any): void {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws {Error} if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id: any): void {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}